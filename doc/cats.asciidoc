Category Theory abstractions for Clojure
========================================
Andrey Antukh & Alejandro Gómez
0.1.0, 2014-06-06

:toc:

Introduction
------------

Category Theory abstractions for Clojure.


Philosophy
~~~~~~~~~

Four most important rules:

- Beautiful is better than ugly
- Explicit is better than implicit
- Simple is better than complex
- Readability counts


Project Maturity
----------------

Since _cats_ is a young project there can be some API breakage.


Install
-------

This section covers installing _cats_.


Requirements
~~~~~~~~~~~~

_cats_ has support for these jvm versions:

- JDK7
- JDK8


Leiningen
~~~~~~~~~

The simplest way to use _cats_ in a Clojure project is by including
it as a dependency in your *_project.clj_*:

._in project.clj_
[source,clojure]
----
[cats "0.1.0-SNAPSHOT"]
----

Maven
~~~~~

Also, you can use it with maven. First, add the clojars repository:

[source,xml]
----
<repository>
    <id>clojars.org</id>
    <url>http://clojars.org/repo</url>
</repository>
----

Then for cats:

[source,xml]
----
<dependency>
    <groupId>cats</groupId>
    <artifactId>cats</artifactId>
    <version>0.1.0-SNAPSHOT</version>
</dependency>
----


Get the Code
~~~~~~~~~~~~

_cats_ is opensource and is entirely developed on link:https://github.com/niwibe/cats[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/niwibe/cats
----


Abstractions Reference
----------------------

Functor
~~~~~~~

The Functor class is the most basic and ubiquitous type class in the _cats_ libraries. A simple
intuition is that a Functor represents a "container" of some sort, along with the ability to apply a
function uniformly to every element in the container. For example, a list is a container of elements,
and we can apply a function to every element of a list, using map. As another example, a binary tree
is also a container of elements, and it’s not hard to come up with a way to recursively apply a
function to every element in a tree.

Another intuition is that a Functor represents some sort of "computational context". This intuition is
generally more useful, but is more difficult to explain, precisely because it is so general. Some
examples later should help to clarify the Functor-as-context point of view.

Definition
^^^^^^^^^^

[source, clojure]
----
(defprotocol Functor
  (fmap [fv f]
    "Applies function f to the value(s) inside
    the context of the functor fv."))
----

[NOTE]
====
The real fmap signature is `(a -> b) -> f a -> f b` that can be traslated to clojure `[f fv]`. The
changed order on protocol parameters definition is required because of clojure's protocols limitation
on dispatch on first argument. You should not use protocol function directly. For it, `cats.core/fmap`
function exists and has the correct signature.
====

Use case
^^^^^^^^

Let see an example of using fmap over some type that implements the `Functor` protocol: `Just`
and `Nothing:

.Apply function `inc` to value `1` wrapped in a `Just`

[source, clojure]
----
(require '[cats.core :refer :all])
(require '[cats.types :refer :all])

(fmap inc (just 1))
;; => #<Just [2]>
----

`fmap` unwrapps the context, apply the function to inner value, and wrap it in a new context. If you
repeat the same operation over `Nothing`, instead of raising some strange exception, it again return
`Nothing` instance:

[source, clojure]
----
(fmap inc (nothing))
;; => #<Nothing >
----

One of the most popular use case for it, is just it, safe operations over possible failure results,
forward error handling to the end of pipeline.


*TODO*: examples using clojure vectors as functor context.


Applicative Functors
~~~~~~~~~~~~~~~~~~~~

Represents an abstraction lying in between Functor and Monad in expressivity.

It encapsulates certain sorts of "effectful" computations in a functionally pure way.

Recall that Functor allows us to lift a "normal" function to a function on computational contexts.
But `fmap` doesn't allow us to apply a function which is itself in a context to a value in a context.
Applicative gives us just such a tool.


Definition
^^^^^^^^^^

[source, clojure]
----
(defprotocol Applicative
  (fapply [af av]
    "Applies the function(s) inside ag's context to the value(s)
     inside av's context while preserving the context.")
  (pure [ctx v]
    "Takes any context monadic value ctx and any value v, and puts
     the value v in the most minimal context of same type of ctx"))
----

Use case
^^^^^^^^

That is hapens if context value is also an computation and you want safety execute it? Applicative
functors is the solution for it.

Let see this code:

[source, clojure]
----
(defn get-greeter
  []
  (let [v (rand-int 2)]
    (case v
      0 (fn [x] (println "hello" x))
      1 nil)))

((get-greeter) "Alex")
----

This code in some situations can raise some exception because `get-greeter` in some circumstances
can return nil (failed result) and for capture it you should constantly check if returned value
from `get-greeter` function is a valid function.

Using applicative functors, you can avoid that:

[source, clojure]
----
(defn get-greeter
  []
  (let [v (rand-int 2)]
    (case v
      0 (just (fn [x] (println "hello" x)))
      1 (nothing))))

(<*> (get-greeter) (just "hello World"))
----

With this code, if `get-greeter` returns nothing, the operation simply return nothing, without
any need catching exceptions or put additional conditionals for check the returned value.

*TODO:* examples using clojure keywords as applicative context.


Data Types Reference
--------------------

We talked about values in a context, but that is a context? Context per se is any value that
wraps an other value inside.

Maybe
~~~~~

Two most common wrapper is "Maybe" (commonly named Optional on not functional programming
languages).

Maybe/Optional is a polymorphic type that represents encapsulation of an optional value; e.g. it is
used as the return type of functions which may or may not return a meaningful value when they
are applied. It consists of either an empty constructor (called None or Nothing), or a constructor
encapsulating the original data type A (written Just A or Some A).

_cats_, implements two constructors:

- `(just v)`: represents just a value in a context.
- `(nothing)`: represents a failure or null.


[source, clojure]
----
(require '[cats.types :refer :all])
(just 1)
;; => #<Just [1]>
(nothing)
;; => #<Nothing >
----

License
-------

[source,text]
----
Copyright (c) 2014, Andrey Antukh
Copyright (c) 2014, Alejandro Gómez

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
